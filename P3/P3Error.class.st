"
I am P3Error.

I get signalled when something goes wrong in using P3Client, either an error inside the driver itself, or an error signalled by the PostgreSQL database backend server.

I should always have a unique code and a message.
Use #isLocal to distinguish between an error inside the driver itself, or an error signalled by the PostgreSQL database backend server.

Reference https://www.postgresql.org/docs/9.6/errcodes-appendix.html
"
Class {
	#name : 'P3Error',
	#superclass : 'Error',
	#instVars : [
		'info'
	],
	#category : 'P3-Core',
	#package : 'P3',
	#tag : 'Core'
}

{ #category : 'accessing' }
P3Error class >> bindCompleteExpected [
	^ self new 
		info: { $C->'P3004'. $M->'BindComplete message expected' } asDictionary; 
		yourself
]

{ #category : 'accessing' }
P3Error class >> cannotConvertTypeOid: typeOid [
	^ self new 
		info: { $C->'P3030'. $M->('Cannot convert type with OID {1}' format: { typeOid }) } asDictionary; 
		yourself
]

{ #category : 'accessing' }
P3Error class >> closeCompleteExpected [
	^ self new 
		info: { $C->'P3005'. $M->'CloseComplete message expected' } asDictionary; 
		yourself
]

{ #category : 'accessing' }
P3Error class >> noDataExpected [
	^ self new 
		info: { $C->'P3001'. $M->'NoData message expected' } asDictionary; 
		yourself
]

{ #category : 'accessing' }
P3Error class >> parseCompleteExpected [
	^ self new 
		info: { $C->'P3002'. $M->'ParseComplete message expected' } asDictionary; 
		yourself
]

{ #category : 'accessing' }
P3Error class >> parsingFailed: detail [
	^ self new 
		info: { $C->'P3031'. $M->('Parsing failed "{1}"' format: { detail }) } asDictionary; 
		yourself
]

{ #category : 'accessing' }
P3Error class >> passwordRequired [
	^ self new 
		info: { $C->'P3010'. $M->'Password required' } asDictionary; 
		yourself
]

{ #category : 'accessing' }
P3Error class >> postgreSQLServerDidNotHonorSSLConnectionRequest [
	^ self new 
		info: { $C->'P3040'. $M->'PostgreSQL server did not honor SSL connection request' } asDictionary; 
		yourself
]

{ #category : 'accessing' }
P3Error class >> readyForQueryExpected [
	^ self new 
		info: { $C->'P3003'. $M->'ReadyForQuery message expected' } asDictionary; 
		yourself
]

{ #category : 'accessing' }
P3Error class >> unexpectedMessageDuringAuthentication [
	^ self new 
		info: { $C->'P3020'. $M->'Unexpected message during authentication' } asDictionary; 
		yourself
]

{ #category : 'accessing' }
P3Error class >> unexpectedMessageDuringStartup [
	^ self new 
		info: { $C->'P3021'. $M->'Unexpected message during startup' } asDictionary; 
		yourself
]

{ #category : 'accessing' }
P3Error class >> unsupportedAuthenticationType: type [
	^ self new 
		info: { $C->'P3022'. $M->('Unsupported authentication type {1}' format: { type }) } asDictionary; 
		yourself
]

{ #category : 'accessing' }
P3Error >> code [
	"Return my unique, locale independent, 5 character string code.
	The first 2 characters are called the class.
	The special P3 class groups errors that were generated locally,
	as opposed to error generated by the PostgreSQL server"
	
	^ self info at: $C ifAbsent: [ nil ]
]

{ #category : 'accessing' }
P3Error >> description [
	"Return a textual description of the exception."

	^ String streamContents: [ :stream |
		stream << self class name.
		self isLocal 
			ifFalse: [ stream space; << 'PostgreSQL' ].
		self messageText isEmptyOrNil
			ifFalse: [ stream space; << self messageText ] ]
]

{ #category : 'accessing' }
P3Error >> info [
	"An info dictionary contains the fields as described in 
	https://www.postgresql.org/docs/9.6/protocol-error-fields.html"

	^ info ifNil: [ info := Dictionary new ]
]

{ #category : 'accessing' }
P3Error >> info: anObject [
	info := anObject
]

{ #category : 'testing' }
P3Error >> isLocal [
	"Return true when I represent an error inside P3 itself,
	as opposed to an error generated by the PostgreSQL server"
	
	^ self code 
		ifNil: [ true "if there is no code, we might have been initialized directly" ] 
		ifNotNil: [ :code | code beginsWith: 'P3' ]
]

{ #category : 'accessing' }
P3Error >> message [
	"Return my user oriented error message string.
	This could be locale dependent.
	My messageText gets initialized from this string"

	^ self info at: $M ifAbsent: [ '' ]
]

{ #category : 'accessing' }
P3Error >> messageText [
	^ messageText ifNil: [ messageText := self message ]
]
